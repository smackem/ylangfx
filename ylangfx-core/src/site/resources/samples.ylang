out := image($in.bounds)
kernel := |1  1  1
           1 -8  1
           1  1  1|
kernel2 := |0 1 2 1 0
            1 2 4 2 1
            2 4 8 4 2
            1 2 4 2 1
            0 1 2 1 0|
for p in $in.bounds {
    out[p] = $in.convolute(p, kernel)
}
out2 := image(out.bounds)
for p2 in out.bounds {
    out2[p2] = -out.convolute(p2, kernel2)
}
return out2

// ================================
// morphological tools
// ================================
fn conv(inp, K) {
    out := image(inp.bounds)
    for p in inp.bounds {
        out[p] = inp.convolve(p, K)
    }
    return out
}

fn smoothen(inp) {
    K := gaussian(5)
    return conv(inp, K)
}

fn sharpen(inp) {
    radius := 2
    K := laplace(radius)
    K[radius;radius] = K[radius;radius] + 1
    return conv(inp, K)
}

fn resize(inp, ratio) {
    out := image(rect(0;0, inp.bounds.width * ratio, inp.bounds.height * ratio))
    for p in out.bounds {
        out[p] = inp[p.x / ratio; p.y / ratio]
    }
    return out
}

fn binarize(inp) {
    out := image(inp.bounds)
    for p in inp.bounds {
        out[p] = inp[p].i01 > 0.6 ? #ffffff : #000000
    }
    return out
}

fn dilate(inp, radius) {
    out := image(inp.bounds)
    K := kernel(radius*2, radius*2, 1)
    K = |0 1 0
         1 1 1
         0 1 0|
    for p in inp.bounds {
        values := inp.selectRed(p, K)
        out[p] = hasNonZero(K, values) ? #ffffff : #000000
    }
    return out
}

fn hasNonZero(selection, values) {
    for i in 0 .. selection.size where selection[i] != 0 and values[i] != 0 {
        return true
    }
    return false
}

fn subtract(left, right) {
    out := image(left.bounds)
    for p in left.bounds {
        out[p] = left[p] - right[p]
    }
    return out
}

inp := $in.default(#ffffff@00)
out := inp//resize(inp, 0.1)
out = smoothen(out)
binarized := binarize(out)
out = dilate(binarized, 2)
out = subtract(out, binarized)
return out
